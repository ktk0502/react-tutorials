{"ast":null,"code":"// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\n\nfunction streamedQuery(_ref) {\n  let {\n    queryFn,\n    refetchMode = \"reset\",\n    maxChunks\n  } = _ref;\n  return async context => {\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n\n    let result = [];\n    const stream = await queryFn(context);\n\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break;\n      }\n\n      if (!isRefetch || refetchMode !== \"replace\") {\n        context.client.setQueryData(context.queryKey, function () {\n          let prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return addToEnd(prev, chunk, maxChunks);\n        });\n      }\n\n      result = addToEnd(result, chunk, maxChunks);\n    }\n\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n\n    return context.client.getQueryData(context.queryKey);\n  };\n}\n\nexport { streamedQuery };","map":{"version":3,"mappings":";AAAA,SAASA,QAAT,QAAyB,YAAzB;;AAkBO,SAASC,aAAT,OAa2C;EAAA,IAVhD;IACAC,OADA;IAEAC,cAAc,OAFd;IAGAC;EAHA,CAUgD;EAChD,OAAO,MAAOC,OAAP,IAAmB;IACxB,MAAMC,QAAQD,QAAQE,MAAR,CACXC,aADW,GAEXC,IAFW,CAEN;MAAEC,UAAUL,QAAQK,QAApB;MAA8BC,OAAO;IAArC,CAFM,CAAd;IAGA,MAAMC,YAAY,CAAC,CAACN,KAAF,IAAWA,MAAMO,KAAN,CAAYC,IAAZ,KAAqB,MAAlD;;IAEA,IAAIF,aAAaT,gBAAgB,OAAjC,EAA0C;MACxCG,MAAMS,QAAN,CAAe;QACbC,QAAQ,SADK;QAEbF,MAAM,MAFO;QAGbG,OAAO,IAHM;QAIbC,aAAa;MAJA,CAAf;IAMF;;IAEA,IAAIC,SAA8B,EAAlC;IACA,MAAMC,SAAS,MAAMlB,QAAQG,OAAR,CAArB;;IAEA,iBAAiBgB,KAAjB,IAA0BD,MAA1B,EAAkC;MAChC,IAAIf,QAAQiB,MAAR,CAAeC,OAAnB,EAA4B;QAC1B;MACF;;MAGA,IAAI,CAACX,SAAD,IAAcT,gBAAgB,SAAlC,EAA6C;QAC3CE,QAAQE,MAAR,CAAeiB,YAAf,CACEnB,QAAQK,QADV,EAEE,YAAe;UAAA,IAAde,IAAc,uEAAP,EAAO;UACb,OAAOzB,SAASyB,IAAT,EAAeJ,KAAf,EAAsBjB,SAAtB,CAAP;QACF,CAJF;MAMF;;MACAe,SAASnB,SAASmB,MAAT,EAAiBE,KAAjB,EAAwBjB,SAAxB,CAAT;IACF;;IAGA,IAAIQ,aAAaT,gBAAgB,SAA7B,IAA0C,CAACE,QAAQiB,MAAR,CAAeC,OAA9D,EAAuE;MACrElB,QAAQE,MAAR,CAAeiB,YAAf,CAAiDnB,QAAQK,QAAzD,EAAmES,MAAnE;IACF;;IAEA,OAAOd,QAAQE,MAAR,CAAemB,YAAf,CAA4BrB,QAAQK,QAApC,CAAP;EACF,CAzCA;AA0CF","names":["addToEnd","streamedQuery","queryFn","refetchMode","maxChunks","context","query","client","getQueryCache","find","queryKey","exact","isRefetch","state","data","setState","status","error","fetchStatus","result","stream","chunk","signal","aborted","setQueryData","prev","getQueryData"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/query-core/src/streamedQuery.ts"],"sourcesContent":["import { addToEnd } from './utils'\nimport type { QueryFunction, QueryFunctionContext, QueryKey } from './types'\n\n/**\n * This is a helper function to create a query function that streams data from an AsyncIterable.\n * Data will be an Array of all the chunks received.\n * The query will be in a 'pending' state until the first chunk of data is received, but will go to 'success' after that.\n * The query will stay in fetchStatus 'fetching' until the stream ends.\n * @param queryFn - The function that returns an AsyncIterable to stream data from.\n * @param refetchMode - Defines how re-fetches are handled.\n * Defaults to `'reset'`, erases all data and puts the query back into `pending` state.\n * Set to `'append'` to append new data to the existing data.\n * Set to `'replace'` to write all data to the cache once the stream ends.\n * @param maxChunks - The maximum number of chunks to keep in the cache.\n * Defaults to `undefined`, meaning all chunks will be kept.\n * If `undefined` or `0`, the number of chunks is unlimited.\n * If the number of chunks exceeds this number, the oldest chunk will be removed.\n */\nexport function streamedQuery<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>({\n  queryFn,\n  refetchMode = 'reset',\n  maxChunks,\n}: {\n  queryFn: (\n    context: QueryFunctionContext<TQueryKey>,\n  ) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>\n  refetchMode?: 'append' | 'reset' | 'replace'\n  maxChunks?: number\n}): QueryFunction<Array<TQueryFnData>, TQueryKey> {\n  return async (context) => {\n    const query = context.client\n      .getQueryCache()\n      .find({ queryKey: context.queryKey, exact: true })\n    const isRefetch = !!query && query.state.data !== undefined\n\n    if (isRefetch && refetchMode === 'reset') {\n      query.setState({\n        status: 'pending',\n        data: undefined,\n        error: null,\n        fetchStatus: 'fetching',\n      })\n    }\n\n    let result: Array<TQueryFnData> = []\n    const stream = await queryFn(context)\n\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break\n      }\n\n      // don't append to the cache directly when replace-refetching\n      if (!isRefetch || refetchMode !== 'replace') {\n        context.client.setQueryData<Array<TQueryFnData>>(\n          context.queryKey,\n          (prev = []) => {\n            return addToEnd(prev, chunk, maxChunks)\n          },\n        )\n      }\n      result = addToEnd(result, chunk, maxChunks)\n    }\n\n    // finalize result: replace-refetching needs to write to the cache\n    if (isRefetch && refetchMode === 'replace' && !context.signal.aborted) {\n      context.client.setQueryData<Array<TQueryFnData>>(context.queryKey, result)\n    }\n\n    return context.client.getQueryData(context.queryKey)!\n  }\n}\n"]},"metadata":{},"sourceType":"module"}