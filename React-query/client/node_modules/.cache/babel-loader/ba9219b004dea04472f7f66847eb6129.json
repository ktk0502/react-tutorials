{"ast":null,"code":"// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult; // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */new Set();\n\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n\n      this.#updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n    }\n\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n\n    const mounted = this.hasListeners();\n\n    if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {\n      this.#executeFetch();\n    }\n\n    this.updateResult();\n\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval();\n\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n\n        if (key === \"promise\" && !this.options.experimental_prefetchInRender && this.#currentThenable.status === \"pending\") {\n          this.#currentThenable.reject(new Error(\"experimental_prefetchInRender feature flag is not enabled\"));\n        }\n\n        return Reflect.get(target, key);\n      }\n    });\n  }\n\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n\n  refetch() {\n    let { ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    return this.#executeFetch({ ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(this.options, fetchOptions);\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(this.options.staleTime, this.#currentQuery);\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const {\n      state\n    } = query;\n    let newState = { ...state\n    };\n    let isPlaceholderData = false;\n    let data;\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = { ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n\n    let {\n      error,\n      errorUpdatedAt,\n      status\n    } = newState;\n    data = newState.data;\n    let skipSelect = false;\n\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options.placeholderData;\n      }\n\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(prevResult?.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = thenable => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n\n      const prevThenable = this.#currentThenable;\n\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n\n          break;\n\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n\n          break;\n\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n\n          break;\n      }\n    }\n\n    return nextResult;\n  }\n\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.#currentResult = nextResult;\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue ?? this.#trackedProps);\n\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n\n      return Object.keys(this.#currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    this.#notify({\n      listeners: shouldNotifyListeners()\n    });\n  }\n\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n\n    if (query === this.#currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate() {\n    this.updateResult();\n\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.#currentResult);\n        });\n      }\n\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n\n};\n\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport { QueryObserver };","map":{"version":3,"mappings":"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","names":["focusManager","notifyManager","fetchState","Subscribable","pendingThenable","isServer","isValidTimeout","noop","replaceData","resolveEnabled","resolveStaleTime","shallowEqualObjects","timeUntilStale","QueryObserver","constructor","client","options","bindMethods","setOptions","Set","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","Error","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","build","result","createResult","shouldAssignObserverCurrentProperties","state","getCurrentResult","trackResult","onPropTracked","Proxy","get","target","key","trackProp","experimental_prefetchInRender","status","reject","Reflect","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","then","fetchOptions","cancelRefetch","promise","throwOnError","catch","isStale","time","dataUpdatedAt","timeout","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","newState","isPlaceholderData","data","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","skipSelect","placeholderData","select","selectError","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","isEnabled","nextResult","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","value","reason","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","Object","keys","some","typedKey","changed","has","onQueryUpdate","notifyOptions","batch","forEach","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","optimisticResult"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        if (\n          key === 'promise' &&\n          !this.options.experimental_prefetchInRender &&\n          this.#currentThenable.status === 'pending'\n        ) {\n          this.#currentThenable.reject(\n            new Error(\n              'experimental_prefetchInRender feature flag is not enabled',\n            ),\n          )\n        }\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}