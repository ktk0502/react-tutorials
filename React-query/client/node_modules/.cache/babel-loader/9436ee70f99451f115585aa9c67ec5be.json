{"ast":null,"code":"// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = {\n        pages: [],\n        pageParams: []\n      };\n      let currentPage = 0;\n\n      const fetchFn = async () => {\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        };\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n\n        return result;\n      };\n\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(fetchFn, {\n            client: context.client,\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\n\nfunction getNextPageParam(options, _ref) {\n  let {\n    pages,\n    pageParams\n  } = _ref;\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams) : void 0;\n}\n\nfunction getPreviousPageParam(options, _ref2) {\n  let {\n    pages,\n    pageParams\n  } = _ref2;\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\n\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\n\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"mappings":"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","names":["addToEnd","addToStart","ensureQueryFn","infiniteQueryBehavior","pages","onFetch","context","query","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","result","currentPage","fetchFn","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","fetchPage","param","previous","Promise","reject","length","resolve","createQueryFnContext","queryFnContext","client","queryKey","pageParam","page","maxPages","addTo","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","remainingPages","initialPageParam","persister","lastIndex","hasNextPage","hasPreviousPage"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"]},"metadata":{},"sourceType":"module"}