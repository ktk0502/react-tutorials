{"ast":null,"code":"// src/mutationObserver.ts\nimport { getDefaultState } from \"./mutation.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { hashKey, shallowEqualObjects } from \"./utils.js\";\nvar MutationObserver = class extends Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n\n    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? getDefaultState();\n    this.#currentResult = { ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n\n  #notify(action) {\n    notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(void 0, action.error, variables, context);\n        }\n      }\n\n      this.listeners.forEach(listener => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n\n};\nexport { MutationObserver };","map":{"version":3,"mappings":"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","names":["getDefaultState","notifyManager","Subscribable","hashKey","shallowEqualObjects","MutationObserver","constructor","client","options","setOptions","bindMethods","mutate","bind","reset","prevOptions","defaultMutationOptions","getMutationCache","notify","type","mutation","observer","mutationKey","state","status","onUnsubscribe","hasListeners","removeObserver","onMutationUpdate","action","getCurrentResult","variables","build","addObserver","execute","isPending","isSuccess","isError","isIdle","batch","context","onSuccess","data","onSettled","onError","error","listeners","forEach","listener"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/query-core/src/mutationObserver.ts"],"sourcesContent":["import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}