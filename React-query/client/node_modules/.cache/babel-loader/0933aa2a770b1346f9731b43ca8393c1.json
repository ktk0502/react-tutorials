{"ast":null,"code":"\"use client\"; // src/HydrationBoundary.tsx\n\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\n\nvar HydrationBoundary = _ref => {\n  let {\n    children,\n    options = {},\n    state,\n    queryClient\n  } = _ref;\n  const client = useQueryClient(queryClient);\n  const optionsRef = React.useRef(options);\n  optionsRef.current = options;\n  const hydrationQueue = React.useMemo(() => {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n\n      const queryCache = client.getQueryCache();\n      const queries = state.queries || [];\n      const newQueries = [];\n      const existingQueries = [];\n\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash);\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery);\n        } else {\n          const hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt || dehydratedQuery.promise && existingQuery.state.status !== \"pending\" && existingQuery.state.fetchStatus !== \"fetching\" && dehydratedQuery.dehydratedAt !== void 0 && dehydratedQuery.dehydratedAt > existingQuery.state.dataUpdatedAt;\n\n          if (hydrationIsNewer) {\n            existingQueries.push(dehydratedQuery);\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        hydrate(client, {\n          queries: newQueries\n        }, optionsRef.current);\n      }\n\n      if (existingQueries.length > 0) {\n        return existingQueries;\n      }\n    }\n\n    return void 0;\n  }, [client, state]);\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, {\n        queries: hydrationQueue\n      }, optionsRef.current);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\n\nexport { HydrationBoundary };","map":{"version":3,"mappings":";;AACA,YAAYA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,cAAT,QAA+B,0BAA/B;;AAoBO,IAAMC,oBAAoB,QAKH;EAAA,IALI;IAChCC,QADgC;IAEhCC,UAAU,EAFsB;IAGhCC,KAHgC;IAIhCC;EAJgC,CAKJ;EAC5B,MAAMC,SAASN,eAAeK,WAAf,CAAf;EAEA,MAAME,aAAmBT,aAAOK,OAAP,CAAzB;EACAI,WAAWC,OAAX,GAAqBL,OAArB;EAiBA,MAAMM,iBACEX,cAAQ,MAAM;IAClB,IAAIM,KAAJ,EAAW;MACT,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;QAC7B;MACF;;MAEA,MAAMM,aAAaJ,OAAOK,aAAP,EAAnB;MAKA,MAAMC,UAAUR,MAAMQ,OAAN,IAAiB,EAAjC;MAEA,MAAMC,aAAyC,EAA/C;MACA,MAAMC,kBAA8C,EAApD;;MACA,WAAWC,eAAX,IAA8BH,OAA9B,EAAuC;QACrC,MAAMI,gBAAgBN,WAAWO,GAAX,CAAeF,gBAAgBG,SAA/B,CAAtB;;QAEA,IAAI,CAACF,aAAL,EAAoB;UAClBH,WAAWM,IAAX,CAAgBJ,eAAhB;QACF,CAFA,MAEO;UACL,MAAMK,mBACJL,gBAAgBX,KAAhB,CAAsBiB,aAAtB,GACEL,cAAcZ,KAAd,CAAoBiB,aADtB,IAECN,gBAAgBO,OAAhB,IACCN,cAAcZ,KAAd,CAAoBmB,MAApB,KAA+B,SADhC,IAECP,cAAcZ,KAAd,CAAoBoB,WAApB,KAAoC,UAFrC,IAGCT,gBAAgBU,YAAhB,KAAiC,MAHlC,IAICV,gBAAgBU,YAAhB,GACET,cAAcZ,KAAd,CAAoBiB,aAR1B;;UAUA,IAAID,gBAAJ,EAAsB;YACpBN,gBAAgBK,IAAhB,CAAqBJ,eAArB;UACF;QACF;MACF;;MAEA,IAAIF,WAAWa,MAAX,GAAoB,CAAxB,EAA2B;QAGzB3B,QAAQO,MAAR,EAAgB;UAAEM,SAASC;QAAX,CAAhB,EAAyCN,WAAWC,OAApD;MACF;;MACA,IAAIM,gBAAgBY,MAAhB,GAAyB,CAA7B,EAAgC;QAC9B,OAAOZ,eAAP;MACF;IACF;;IACA,OAAO,MAAP;EACF,CA/CM,EA+CH,CAACR,MAAD,EAASF,KAAT,CA/CG,CADR;EAkDMN,gBAAU,MAAM;IACpB,IAAIW,cAAJ,EAAoB;MAClBV,QAAQO,MAAR,EAAgB;QAAEM,SAASH;MAAX,CAAhB,EAA6CF,WAAWC,OAAxD;IACF;EACF,CAJM,EAIH,CAACF,MAAD,EAASG,cAAT,CAJG;EAMN,OAAOP,QAAP;AACF,CAnFO","names":["React","hydrate","useQueryClient","HydrationBoundary","children","options","state","queryClient","client","optionsRef","current","hydrationQueue","queryCache","getQueryCache","queries","newQueries","existingQueries","dehydratedQuery","existingQuery","get","queryHash","push","hydrationIsNewer","dataUpdatedAt","promise","status","fetchStatus","dehydratedAt","length"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/react-query/src/HydrationBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state: DehydratedState | null | undefined\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = state.queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"]},"metadata":{},"sourceType":"module"}