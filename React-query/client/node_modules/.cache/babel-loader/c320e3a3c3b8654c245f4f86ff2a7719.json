{"ast":null,"code":"// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, resolveStaleTime, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  get promise() {\n    return this.#retryer?.promise;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => resolveEnabled(observer.options.enabled, this) !== false);\n  }\n\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => resolveStaleTime(observer.options.staleTime, this) === \"static\");\n    }\n\n    return false;\n  }\n\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (this.state.data === void 0) {\n      return true;\n    }\n\n    if (staleTime === \"static\") {\n      return false;\n    }\n\n    if (this.state.isInvalidated) {\n      return true;\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n\n  onOnline() {\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.#cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: \"invalidate\"\n      });\n    }\n  }\n\n  async fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\" && // If the promise in the retyer is already rejected, we have to definitely\n    // re-start the fetch; there is a chance that the query is still in a\n    // pending state when that happens\n    this.#retryer?.status() !== \"rejected\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n\n    if (options) {\n      this.setOptions(options);\n    }\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n      }\n    }\n\n    const abortController = new AbortController();\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n\n      const queryFnContext = createQueryFnContext();\n      this.#abortSignalConsumed = false;\n\n      if (this.options.persister) {\n        return this.options.persister(queryFn, queryFnContext, this);\n      }\n\n      return queryFn(queryFnContext);\n    };\n\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n\n    const context = createFetchContext();\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({\n        type: \"fetch\",\n        meta: context.fetchOptions?.meta\n      });\n    }\n\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onFail: (failureCount, error) => {\n        this.#dispatch({\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.#dispatch({\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        this.#dispatch({\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n\n    try {\n      const data = await this.#retryer.start();\n\n      if (data === void 0) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);\n        }\n\n        throw new Error(`${this.queryHash} data is undefined`);\n      }\n\n      this.setData(data);\n      this.#cache.config.onSuccess?.(data, this);\n      this.#cache.config.onSettled?.(data, this.state.error, this);\n      return data;\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          return this.#retryer.promise;\n        } else if (error.revert) {\n          this.setState({ ...this.#revertState,\n            fetchStatus: \"idle\"\n          });\n\n          if (this.state.data === void 0) {\n            throw error;\n          }\n\n          return this.state.data;\n        }\n      }\n\n      this.#dispatch({\n        type: \"error\",\n        error\n      });\n      this.#cache.config.onError?.(error, this);\n      this.#cache.config.onSettled?.(this.state.data, error, this);\n      throw error;\n    } finally {\n      this.scheduleGc();\n    }\n  }\n\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case \"pause\":\n          return { ...state,\n            fetchStatus: \"paused\"\n          };\n\n        case \"continue\":\n          return { ...state,\n            fetchStatus: \"fetching\"\n          };\n\n        case \"fetch\":\n          return { ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n\n        case \"success\":\n          const newState = { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...(!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n          this.#revertState = action.manual ? newState : void 0;\n          return newState;\n\n        case \"error\":\n          const error = action.error;\n          return { ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n\n        case \"invalidate\":\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case \"setState\":\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n\n};\n\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...(data === void 0 && {\n      error: null,\n      status: \"pending\"\n    })\n  };\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\nexport { Query, fetchState };","map":{"version":3,"mappings":"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","names":["ensureQueryFn","noop","replaceData","resolveEnabled","resolveStaleTime","skipToken","timeUntilStale","notifyManager","CancelledError","canFetch","createRetryer","Removable","Query","constructor","config","defaultOptions","setOptions","options","observers","client","getQueryCache","queryKey","queryHash","getDefaultState","state","scheduleGc","meta","promise","updateGcTime","gcTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","queryFn","dataUpdateCount","errorUpdateCount","isStatic","staleTime","isStale","getCurrentResult","isInvalidated","isStaleByTime","onFocus","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetchOptions","status","continueRetry","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","createQueryFnContext","queryFnContext","persister","createFetchContext","context","behavior","onFetch","fetchMeta","initialPromise","fn","abort","bind","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","Error","onSuccess","onSettled","onError","action","reducer","fetchFailureCount","fetchFailureReason","fetchState","newState","Date","now","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["/Users/kartikaypratapsingh/Desktop/React_tut/React-query/client/node_modules/@tanstack/query-core/src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { CancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  async fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (\n      this.state.fetchStatus !== 'idle' &&\n      // If the promise in the retyer is already rejected, we have to definitely\n      // re-start the fetch; there is a chance that the query is still in a\n      // pending state when that happens\n      this.#retryer?.status() !== 'rejected'\n    ) {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    try {\n      const data = await this.#retryer.start()\n      // this is more of a runtime guard\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (data === undefined) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(\n            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n          )\n        }\n        throw new Error(`${this.queryHash} data is undefined`)\n      }\n\n      this.setData(data)\n\n      // Notify cache callback\n      this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n      this.#cache.config.onSettled?.(\n        data,\n        this.state.error as any,\n        this as Query<any, any, any, any>,\n      )\n      return data\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          // silent cancellation implies a new fetch is going to be started,\n          // so we hatch onto that promise\n          return this.#retryer.promise\n        } else if (error.revert) {\n          this.setState({\n            ...this.#revertState,\n            fetchStatus: 'idle' as const,\n          })\n          // transform error into reverted state data\n          // if the initial fetch was cancelled, we have no data, so we have\n          // to get reject with a CancelledError\n          if (this.state.data === undefined) {\n            throw error\n          }\n          return this.state.data\n        }\n      }\n      this.#dispatch({\n        type: 'error',\n        error: error as TError,\n      })\n\n      // Notify cache callback\n      this.#cache.config.onError?.(\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n      this.#cache.config.onSettled?.(\n        this.state.data,\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n\n      throw error // rethrow the error for further handling\n    } finally {\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success' as const,\n            ...(!action.manual && {\n              fetchStatus: 'idle' as const,\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          // For manual updates, capture the state to revert to it in case of a cancellation.\n          this.#revertState = action.manual ? newState : undefined\n\n          return newState\n        case 'error':\n          const error = action.error\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"]},"metadata":{},"sourceType":"module"}